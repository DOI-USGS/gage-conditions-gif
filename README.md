# gage conditions

This repo contains code used to create the recurring `U.S. River Conditions` animation series, an example of which can be seen [here](https://www.usgs.gov/media/videos/us-river-conditions-january-march-2022). The name of this repo is a bit of a misnomer because at present this code will produce a video file, not a gif. However, the code used to create a gif version is still available in `6_visualize/src/combine_animation_frames.R` > `combine_animation_frames_gif()`.

*Instructions generated by Lindsay Platt*

## Before you build

Note that before you can just build this as the code suggests, you will have to have the appropriate permissions to our intermediate data products. Mainly, this is access to the Google Drive folder which we grant to internal users and close collaborators.

## How to build this animation

The process to create this animation is almost entirely automated using the (now dormant) custom dependency management R package, `scipiper`. There is a bit of manual work required to create and then prepare the animation's event/text callouts. Otherwise, it is mostly running chunks of code. The entire process is outlined below.

1. Change the animation dates and download/process the new data
1. Create a new blank animation to use for event callout inspiration
1. Gather event callouts and add to the animation
1. Tweak event callout timing and appearance
1. Generate final video animation (by default, the animation is optimized for Twitter)
1. Run code for simple-to-produce outreach artifacts (USGS VisID version, Facebook-optimized version, Reddit optimized version, USGS Drupal carousel image, USGS VisID thumbnail, and lastly a square thumbnail)
1. Restructure code and build a new Instagram version

*I plan to come back later and add instructions for how to generate the full water year animation*

The outputs from following this full process should be the following files:

* `6_visualize/out/river_conditions_[month start]_[month end]_[year]_twitter.mp4`
* `6_visualize/out/river_conditions_[month start]_[month end]_[year]_visid.mp4`
* `6_visualize/out/river_conditions_[month start]_[month end]_[year]_facebook.mp4`
* `6_visualize/out/river_conditions_[month start]_[month end]_[year]_reddit.mp4`
* `6_visualize/out/river_conditions_[month start]_[month end]_[year]_carousel.png`
* `6_visualize/out/river_conditions_[month start]_[month end]_[year]_visid_thumbnail.png`
* `6_visualize/out/river_conditions_[month start]_[month end]_[year]_square_thumbnail.png`
* `6_visualize/out/river_conditions_[month start]_[month end]_[year]_insta.mp4`

### Change the animation dates and download/process the new data

You can do this step the day after the desired visualization date range ends. We typically build these quarterly, so you would kick this step off on January 1 for quarter 1's animation (October 1 - December 31), and so on for the other quarters. Typically, we start this step on ...

* January 1st for quarter one's (Oct 1 - Dec 31) animation 
* April 1st for quarter two's (Jan 1 - Mar 31) animation 
* July 1st for quarter three's (Apr 1 - Jun 30) animation - *note that this timing can be tricky given the July 4th holiday*
* October 1st for quarter four's (Jul 1 - Sep 30) animation 

#### Update the dates

Go to `viz_config.yml` and make sure that the start/end entries for both `vizDates` and `wheelDates` are appropriate. `vizDates` refer to the dates that will be shown as animation frames and for which data will be pulled. `wheelDates` should be the start/end dates for the current water year and are used to construct the date wheel visual on the bottom left of the animation.

Next, scroll down in `viz_config.yml` and ensure that the field `title_cfg > subtitle` shows the appropriate dates. While you're at it, update the same field but in the commented out area which will be used later to create an Instagram version of the animation.

#### Run code to download the data

First, verify that you are logged into Google Drive (GD). If you don't do this step or it times out, it can error on the last step of any given data download which pushes the data to GD (wah wah). If the command gives you multiple account options, make sure you click the account that was given permission to this repo's GD folder.

```r
googledrive::drive_auth()
```

Next, actually download the data by running the following code which kicks off the lengthy data processing steps. Note that this will take multiple hours. I usually plan on kicking this off in the morning and then getting back to it right at the end of the day, or even the next day. It also prints a lot to the console.

```
# TODO: I think that there is a way to do this without specifying all of 
# these individually, but this has been working for me so let's save that 
# change for a rainy day.

scipiper::scmake("1_fetch/out/dv_data.rds.ind", "1_fetch.yml")
scipiper::scmake("1_fetch/out/dv_data_fixed_gh.rds.ind", "1_fetch.yml")
scipiper::scmake("1_fetch/out/sites_stage.rds.ind", remake_file = "1_fetch.yml")
scipiper::scmake("2_process/out/dv_stats.rds.ind", "2_process.yml")
scipiper::scmake("2_process/out/dv_stats_fixed_gh.rds.ind", "2_process.yml")
scipiper::scmake("2_process/out/dv_stat_styles.rds.ind", "2_process.yml")
```
### Create a new blank animation to use for event callout inspiration

Unless you have already know what the callouts will be, you should generate a blank version of the animation to use and share with collaborators in order to generate event callouts. If you already have callouts, still do the configuration steps here but don't bother rebuilding the animation frames until after you've followed the instructions further down to incorporate callouts into the animation.

#### Configuration step: clear `6_visualize/tmp`

In the end, the animation is created by stitching together a bunch of individual PNG frames. The code is currently setup to just use any file within the folder `6_visualize/tmp`. Thus, we need to clear (or rename) that folder to prevent old frames from appearing in our new visualization. If this folder doesn't exist for you, please create it and leave it empty for now.

Note that I included "or rename" as an option because sometimes you need to quickly rebuild the full animation but don't need to rebuild each animation frame. By renaming the folder, you can always go back later, put the name back to `6_visualize/tmp` and then build the animation using those previous frames. It's a nice workaround if you need it.

#### Configuration step: clear `callouts_cfg.yml`

The animation's event callouts are added via the `callouts_cfg.yml` file. This file has a very specific structure so that the code can grab the information it needs to add them to the animation. Details about how to construct this file are included later on, but for this step we need to create an empty `callouts_cfg.yml` file to avoid old callouts ending up on our new animation. If there is already an existing `callouts_cfg.yml` file in your directory, I suggest renaming or deleting it. I like to save previous versions of this file until the next water year begins in order to make the full water year animation creation easier. So, I would rename using the appropriate water year and quarter identifiers, e.g. `callouts_cfg_wy21_q2.yml`, and then delete ones from previous water years at a later date. Once you've either renamed or deleted `callouts_cfg.yml` (or it never existed to begin with), run `file.create("callouts_cfg.yml")` to create the empty version. Note that the file must exist for the rest of the code to run, even if it is just empty.

#### Build all animation frames and then the first, blank animation

Now that you don't have any files in `6_visualize/tmp` or any content in `callouts_cfg.yml`, you can build the initial, blank version of the animation. Note that this repo was one of the first `scipiper` repos that we constructed and is not following all of the best practices that were learned later (*ahem* the over use of `force=TRUE` *ahem*). In the spirit of "if it's not broken, don't fix it" and prioritization of future projects rather than this known technical debt, we will just ignore such quirks here unless they disrupt our ability to create the animation from this repo.

First, in order for the frames to use the appropriate font, we need to load it in each R session where we are building the frames using the function below. If you don't do this, the code won't error but your final frame(s) will not have the correct font.

```r
sysfonts::font_add_google('Abel','abel')
```

The animation is chunked into four sections:

1. `intro` - the title slide that fades in and out
1. `timestep` - each day's data with the map & datewheel visuals updating
1. `pause` - the last frame of the animation repeated for a certain amount of time
1. `final` - the final informational statement about GWSIP that fades in and out

The intro and final frames should only need to be build once when you are kicking off a new version since they only depend on the date range and won't be impacted by tweaks in callouts. To build the intro and final frames, run the following:

```r
# Build the intro frames
scipiper::scmake('6_intro_gif_tasks.yml', remake_file = '6_visualize.yml', force = TRUE)
scipiper::scmake('6_visualize/log/6_intro_gif_tasks.ind', remake_file = '6_visualize.yml', force=TRUE)

# Build the final frames
scipiper::scmake('6_final_gif_tasks.yml', remake_file = '6_visualize.yml', force = TRUE)
scipiper::scmake('6_visualize/log/6_final_gif_tasks.ind', remake_file = '6_visualize.yml', force=TRUE)
```

The frames that are impacted by changes in callouts will be the timestep and pause sections. You will likely need to rebuild these frames a number of times as you work on the appearance and timing of callouts. To build the timestep and pause frames, run the following:

```r
# Build the timestep frames
scipiper::scmake('6_timestep_gif_tasks.yml', remake_file = '6_visualize.yml', force = TRUE)
scipiper::scmake('6_visualize/log/6_timestep_gif_tasks.ind', remake_file = '6_visualize.yml', force=TRUE)

# Build the pause frames
scipiper::scmake('6_pause_gif_tasks.yml', remake_file = '6_visualize.yml', force=TRUE)
scipiper::scmake('6_visualize/log/6_pause_gif_tasks.ind', remake_file = '6_visualize.yml', force=TRUE)
```

To stitch the completed frames together into a single video animation, run the following:

```r
scipiper::scmake('6_visualize/out/year_in_review.mp4', remake_file = '6_visualize.yml', force = TRUE)
```

Now, you can go view the draft animation at `6_visualize/out/year_in_review.mp4`. Before sharing with collaborators, I usually rename this to `river_conditions_[month start]_[month end]_[year]_draft.mp4`.

### Gather event callouts and add to the animation

#### Populate the initial `callouts_cfg.yml`

You should either request or generate callouts in a table with three columns: `Start`, `End`, and `Label` (as shown below).

Start | End | Label
-- | -- | --
4/5/2022 | 4/21/2022 | Fronts bring high water to parts of the Eastern and Southern U.S.
4/23/2022 | 6/7/2022 | Rain and snowmelt bring flooding to the Upper Midwest
4/27/2022 | 5/6/2022 | A dry period for the Mid-Atlantic

Then, save the callouts table in an Excel file called `input_callouts.xlsx` and run the following code to generate the initial `callouts_cfg.yml` file.

```r
library(dplyr)

callout_data <- readxl::read_excel("input_callouts.xlsx") %>%
  # Make columns match what the mustache template expects
  rename(start_date = Start,
         end_date = End,
         label = Label)

# Turn data frame into list
callouts_list <- split(callout_data, seq(nrow(callout_data)))
callouts_string_list <- lapply(callouts_list, function(x) {
  callout_list_t <- t(x)
  callout_list_data <- setNames(split(callout_list_t, seq(nrow(callout_list_t))), rownames(callout_list_t))
  whisker::whisker.render(readLines("1_fetch/in/callout_template.mustache"), data = callout_list_data)
})

# Save output as file
writeLines(unlist(lapply(callouts_string_list, paste, collapse=" ")), "callouts_cfg.yml")
```

#### Update the `callouts_cfg.yml`

The initial callouts from the table were inserted into a yml structure with the default settings for each callout as specified in `1_fetch/in/callout_template.mustache`. Now that those initial callouts are there, it is time to go update their settings before rebuilding the animation. You can do these somewhat in the order written below, but there is also some iteration that will need to occur.

* **Single or multi-line text.** Decide whether you want the text to appear on one line or multiple lines. By default the text will appear on one line. If you want to create multiple lines, you will need to add square brackets around the text string and then make each line a string separated by commas, e.g. `["This is line 1", "and this is line 2"]`.
* **Text justification.** Use `pos` to declare whether you want the text to appear left justified (`pos = 4`), right justified (`pos=2`), or centered (`pos=1` or `pos=3`).
* **Text location.** Adjust `x_loc` and `y_loc` to change where the text appears. The value of `pos` will matter here since pos changes whether your text is below (`pos=1`), left of (`pos=2`), above (`pos=3`), or right of (`pos=4`) the x and y location you specify. The x and y location values are the fraction corresponding to the full image, starting from the bottomleft. See `6_visualize/in/frame_grid_xy_callout_locations.png` for some helpful positions of x and y location values and where they appear on the animation frame.
* **Event type.** Each event callout is given a box indicating the event duration on the date wheel visual on the bottomleft of the frame. By default, events are given a blue color (`"#04507d"`) for `wheel_color`. Update the event to a red color (`"#ca0020"`) if the event describes a drought or dry event.

These are the only elements you need to change right now. We will iterate on the others later.

*You may be wondering what the `polygon` element under each callout is for ... don't worry about this and leave as the default. We will hopefully add information about those at a later date.*

#### Rebuild the frames and animation with the callouts

Using the initial callouts timing and placement, generate a new animation by updating the appropriate frames and then rebuilding the video using the code below.

```r
# Ensure the correct font is still loaded
sysfonts::font_add_google('Abel','abel')

# Build the timestep frames
scipiper::scmake('6_timestep_gif_tasks.yml', remake_file = '6_visualize.yml', force = TRUE)
scipiper::scmake('6_visualize/log/6_timestep_gif_tasks.ind', remake_file = '6_visualize.yml', force=TRUE)

# Build the pause frames
scipiper::scmake('6_pause_gif_tasks.yml', remake_file = '6_visualize.yml', force=TRUE)
scipiper::scmake('6_visualize/log/6_pause_gif_tasks.ind', remake_file = '6_visualize.yml', force=TRUE)

# Build the animation
scipiper::scmake('6_visualize/out/year_in_review.mp4', remake_file = '6_visualize.yml', force = TRUE)
```

Sometimes, I notice that the `pause` frames are not updating as they should. There are not many of them, so if this happens I delete the individual frames manually and then rebuild. To delete manually, find any frame in `6_visualize/tmp` prefixed with `frame_6000`.

### Tweak event callout timing and appearance

This is usually where I spend the most hands-on time because it is where you iterate on how the callouts integrate with the animation. Usually, the first animation is not ready for publication because callouts may overlap each other visually or temporally, some may extend the full length of the animation which isn't very useful, and others may blip on and then off too quickly for a user to read. Below we detail the other attributes and methods that you can use to polish the final visualization.

#### Event timing

To understand how events overlap and what you may want to update about them, run this code to generate a plot showing all the events and when they appear in the animation. It uses the dates in `callouts_cfg.yml`, so if you update those and save that file, rerun this code to see the new plot.

```r
dates_of_events <- lapply(yaml::read_yaml("callouts_cfg.yml"), function(x) {
  tibble(label = paste(x$text$label, collapse = " "), 
         start = as.Date(x$event_dates$start), end = as.Date(x$event_dates$end),
         txt_s = as.Date(x$text_dates$start), txt_e = as.Date(x$text_dates$end)) %>% 
      mutate(
          txt_in = txt_s - ifelse(is.null(x$fade_in), 9, x$fade_in), 
          txt_out = txt_e + ifelse(is.null(x$fade_out), 9, x$fade_out)
      )
}) %>% bind_rows() %>% 
    # Order the figure output based on event start date
    arrange(start) %>% 
    mutate(label = factor(label, levels = label, ordered = TRUE))

library(ggplot2)
ggplot(dates_of_events, aes(y = 1, yend = 1)) +
  geom_segment(aes(x = start, xend = end), size = 3) +
  geom_segment(aes(y = 0.5, yend = 0.5, x = txt_s, xend = txt_e), size = 2, color = "blue") +
  geom_segment(aes(y = 0.5, yend = 0.5, x = txt_in, xend = txt_out), size = 1, color = "red", linetype = "dotted") +
  ylim(0, 2) +
  geom_text(aes(x = start, y = 1.5, label = label), hjust = 0) +
  facet_grid(label ~ .) + 
  theme(axis.text=element_blank(), axis.ticks=element_blank(),
        strip.background = element_blank(), strip.text = element_blank(),
        axis.title = element_blank(), panel.grid = element_blank(),
        panel.spacing = unit(0, "lines"))
```

* **Event appearance on the datewheel.** The `event_dates` and `wheel_hierarchy` attributes determine how an event will appear on the datewheel in the bottomleft of the animation frame. The goal is for us to see all of the events in one view. You should mostly be adjusting `wheel_hierarchy` (which defaults to 1 but ranges from 0-3) to change which appear in front and short (`wheel_hierarchy=0`) or behind and tall (`wheel_hierarchy=3`). Sometimes, two events overlap by 1 day and you want them to be the same `wheel_hierarchy`. In this rare instance, I adjust the `event_dates` on one of them to be 1-2 days earlier or later for visual separation. While this is not ideal, it provides for the visual separation we need on the datewheel.
* **Event timing.** There are three attributes that deal with when a callout is visible - `text_dates`, `fade_in`, and `fade_out`. `text_dates` will match the `event_dates` by default. You can play with these dates and the number of frames it takes to `fade_in` and `fade_out` to adjust when the text appears on the map. Changing the `text_dates` is independent of the `event_dates` (which should be mostly left alone). Adjusting the dates we see the text is especially necessary for events that are super short (like flash floods) or super long (like extended drought) in duration.

#### Event text appearance

As you iterate through other parts of the text appearance, you probably don't want to keep waiting for the full animation to rebuild every time. You may be interested in generating just a single frame that occurs during all or one of the events you are adjusting. Below are some code to generate the individual frame(s). After you run the code, head over to `6_visualize/tmp` in the Files window of RStudio and sort by `Modified`.

```r
# Build a frame for the middle of each event

dates_to_build <- lapply(lapply(yaml::read_yaml("callouts_cfg.yml"), '[[', "text_dates"), function(x) {
  endDate <- as.Date(x$end)
  startDate <- as.Date(x$start)
  halfwayDate <- startDate + (endDate - startDate)/2
  return(halfwayDate)
}) %>% unlist() %>% as.Date(origin = "1970-01-01") %>% format("%Y%m%d")

# Don't forget the font: 
sysfonts::font_add_google('Abel','abel')
scipiper::scmake(sprintf('6_visualize/tmp/frame_%s_00.png', dates_to_build), '6_timestep_gif_tasks.yml', force=TRUE)
```

You may even have a specific frame or range of frames you want to build. Here's some code to do that:

```r
# Don't forget that you need the font!
sysfonts::font_add_google('Abel','abel')

# Build a specific subset of days
days <- c(20220607:20220617)
scipiper::scmake(sprintf('6_visualize/tmp/frame_%s_00.png', days), '6_timestep_gif_tasks.yml')

# Build a single frame:
scipiper::scmake('6_visualize/tmp/frame_20220530_00.png', '6_timestep_gif_tasks.yml')
```

* **Text location, justification, and layout.** Described earlier so that you could get an initial view with callouts, these same elements (`label`, `pos`, `x_loc`, `y_loc`) are likely to be adjusted during your polishing iterations. 
* **Text size.** You can increase or decrease the text size from the default of `cex=6`, but we recommend not going smaller if possible.
* **Box behind text.** `add_box` is initially left blank which means that no box will be added behind the text. If your text is particularly diffcult to read given the data points behind it's location, you may want to add a grey box by changing to `add_box=TRUE`.

### Generate final video animation

Once you are satisfied with the timing and appearance of your callouts and the datewheel, it is time to prepare a version to share out. Now, you may already have a version ready to go, but I like to just rebuild everything one more time knowing that my `callout_cfgs.yml` has the final up-to-date information for everything, especially if I've been individually building frames as I have been iterating. To do that, just rebuild the frames and the video animation as we did earlier (remember, you might need to manually delete any pause pngs prefixed `frame_6000` before this):

```r
# Load that font again just in case! It's easy and quick to run but terrible
# to realize your fonts are all wrong after the frames rebuild
sysfonts::font_add_google('Abel','abel')

# Build the intro frames
scipiper::scmake('6_intro_gif_tasks.yml', remake_file = '6_visualize.yml', force = TRUE)
scipiper::scmake('6_visualize/log/6_intro_gif_tasks.ind', remake_file = '6_visualize.yml', force=TRUE)

# Build the timestep frames
scipiper::scmake('6_timestep_gif_tasks.yml', remake_file = '6_visualize.yml', force = TRUE)
scipiper::scmake('6_visualize/log/6_timestep_gif_tasks.ind', remake_file = '6_visualize.yml', force=TRUE)

# Build the pause frames
scipiper::scmake('6_pause_gif_tasks.yml', remake_file = '6_visualize.yml', force=TRUE)
scipiper::scmake('6_visualize/log/6_pause_gif_tasks.ind', remake_file = '6_visualize.yml', force=TRUE)

# Build the final frames
scipiper::scmake('6_final_gif_tasks.yml', remake_file = '6_visualize.yml', force = TRUE)
scipiper::scmake('6_visualize/log/6_final_gif_tasks.ind', remake_file = '6_visualize.yml', force=TRUE)

# Build the animation
scipiper::scmake('6_visualize/out/year_in_review.mp4', remake_file = '6_visualize.yml', force = TRUE)
```

Next, I rename the output file from `6_visualize/out/year_in_review.mp4` to `6_visualize/out/river_conditions_[month start]_[month end]_[year]_prototype.mp4`. I share this out and get feedback/approval from the various groups I need to (GWSIP collaborators, Vizlab lead, Data Science Chief, and IIDD Director). I incorporate edits using the iterative techniques employed earlier and then regenerate one more version but rename to `6_visualize/out/river_conditions_[month start]_[month end]_[year]_twitter.mp4`.

Now, I share the Twitter version with collaborators in Web Communications so that they may start pulling together social media. They will also help develop the descriptive text that can accompany the visualization to meet accessibility needs. I have found that providing tabular version of the final events we feature is useful. To create that, run this code:

```r
# Create a table from the final callouts to share as needed
lapply(yaml.load_file("callouts_cfg.yml"), function(x) {
  tibble(EventDescription = paste(x$text$label, collapse = " "),
         EventStart = x$event_dates$start,
         EventEnd = x$event_dates$end)
}) %>% 
  bind_rows() %>% 
  filter(nchar(EventDescription) > 0) %>% 
  arrange(EventStart, EventEnd) %>% 
  View()
```

### Run code for simple-to-produce outreach artifacts

While the social media plan is being developed using `6_visualize/out/river_conditions_[month start]_[month end]_[year]_twitter.mp4`, you can go ahead and start building all of the other social media content. There are a few configurations you need to set before moving ahead and running all the associated code.

1. Choose a new date to feature as the static image frame. This will be used in any of the static images, so choose one that is interesting!
2. Update and run the following code so that all subsequent code chunks can take advantage of the updated information.

```r
# Update to the appropriate [month start]_[month end]_[year] so that this can be used when naming all other outputs
version_info <- "river_conditions_apr_jun_2022" 

# Update to the date you want to use for any still frames
frame_to_use <- "6_visualize/tmp/frame_20220616_00.png" 

# Specify the time (in seconds) associated with the frame you want to appear as the Reddit preview
frame_to_use_t <- 38

# This function is used in many of the following code chunks
run_magick_cmd <- function(command_str) {
  if(Sys.info()[['sysname']] == "Windows") {
    magick_command <- sprintf('magick %s', command_str)
  } else {
    magick_command <- command_str
  }
  system(magick_command)
}
```

Note that if you restart R between running the above and any of the code chunks below, you will need to rerun these lines above so that the objects and functions exist in your environment.

#### USGS VisID animation

This reshapes the video frame, removes the existing logo, and adds the necessary black bar with USGS logo at the bottom of the video.

```r
# This works very well for viz_config height and width of 2048 & 4096.
# Unsure about what changes may be needed for other dimensions.

# Get viz frame dimensions and then divide by 2 bc we 
# double them in combine_animation_frame
timestep_frame_config <- remake::fetch("timestep_frame_config")
viz_config_dim <- lapply(timestep_frame_config, function(x) x/2) 

# Identify files
video_file <- sprintf("6_visualize/out/%s_twitter.mp4", version_info)
video_logo_cover_file <- "6_visualize/tmp/video_logocovered_for_visid.mp4"
video_scaled_for_visid_file <- "6_visualize/tmp/video_scaled_for_visid.mp4"
visid_file <- "6_visualize/in/visid_overlay.png"
video_w_visid_file <- sprintf("6_visualize/out/%s_visid.mp4", version_info)

# Cover up the existing USGS logo
system(sprintf(
  'ffmpeg -y -i %s -vf "drawbox=x=0:y=ih-h:w=%s/6:h=%s/8:t=max:color=white" %s', 
  video_file, 
  viz_config_dim$width, 
  viz_config_dim$height,
  video_logo_cover_file
))

# Scale and pad the existing video to fit the black bottom bar
# without changing aspect ratio
system(sprintf(
    'ffmpeg -y -i %s -vf "scale=%s:%s,pad=%s:%s:(ow-iw)/2:color=white" %s', 
    video_logo_cover_file,
    viz_config_dim$width-viz_config_dim$width*0.08691406, 
    viz_config_dim$height-viz_config_dim$height*0.08691406,
    viz_config_dim$width, 
    viz_config_dim$height,
    video_scaled_for_visid_file
))

# Overlay the visid black bar onto video
system(sprintf(
    'ffmpeg -y -i %s -i %s -filter_complex "overlay" -c:v libx264  %s', 
    video_scaled_for_visid_file,
    visid_file,
    video_w_visid_file))
```

#### USGS Facebook animation

The VisID version of the animation is not the right aspect ratio and is too large for Facebook. This updates the aspect ratio and scales the video size down, so that the output is compatible and optimized for Facebook.

```r
video_file <- sprintf("6_visualize/out/%s_visid.mp4", version_info)
video_resized_for_facebook <- "6_visualize/tmp/video_facebook_aspect_ratio.mp4"
video_downscaled_for_facebook <- sprintf("6_visualize/out/%s_facebook.mp4", version_info)

# Get viz frame dimensions and then divide by 2 bc we 
# double them in combine_animation_frame
timestep_frame_config <- remake::fetch("timestep_frame_config")
viz_config_dim <- lapply(timestep_frame_config, function(x) x/2) 

# need to have 16:9, not 2:1
new_height <- viz_config_dim$width * 9/16

# Scale and pad the existing video to fit 16:9 aspect ratio
#   0.8691406 is the scale factor from above for the width
#     of the logo black bar. Using it here means that we are centering
#     the image and taking that black bar into account. It's a bit
#     of a mystery to me still but it worked!
system(sprintf(
    'ffmpeg -y -i %s -vf "pad=%s:%s:0:(oh-ih)*0.8691406:color=black" %s', 
    video_file,
    viz_config_dim$width, 
    new_height,
    video_resized_for_facebook
))

# Scale down size so it doesn't upload as a 360 video
scale_factor <- 1280 / viz_config_dim$width # 1280 = optimal facebook width 

system(sprintf(
    'ffmpeg -y -i %s -vf "scale=%s:%s" %s', 
    video_resized_for_facebook,
    viz_config_dim$width * scale_factor,
    new_height * scale_factor,
    video_downscaled_for_facebook
))

```

#### Reddit animation

Do this by adding one single still image before the video.

```r
# Make video with still image before
viz_config <- scmake("viz_config")
video_reddit <- sprintf("6_visualize/out/%s_reddit.mp4", version_info)
video_in <- sprintf("6_visualize/out/%s_twitter.mp4", version_info)
video_still_frame <- "6_visualize/tmp/video_still_frame.mp4"

# First, cut out just this frame from video
system(sprintf(
  'ffmpeg -y -i %s -ss 00:00:%s -t 00:00:00.5 %s', 
  video_in,
  sprintf("%02d", frame_to_use_t),
  video_still_frame
))

# Then, add to video
# Bring them all together
file.copy(video_in, sprintf("6_visualize/tmp/%s", basename(video_in)))
files_to_cat_fn <- "6_visualize/tmp/videos_to_concat.txt"
writeLines(sprintf("file '%s'", c(basename(video_still_frame), basename(video_in))), files_to_cat_fn)

system(sprintf(
  'ffmpeg -y -safe 0 -f concat -i %s -c copy %s',
  files_to_cat_fn,
  video_reddit
))
```

#### USGS Drupal carousel image

This still image is used on the GWSIP home page in the image carousel when the new animation is linked there by the Web Communications team. It is an awkwardly large size, so this creates the appropriately sized image with a white background and then centers our still frame on it.

```r
run_magick_cmd("convert -size 11400x3721 canvas:white 6_visualize/tmp/carousel_background.png")
run_magick_cmd(sprintf("convert -composite -gravity center 6_visualize/tmp/carousel_background.png %s 6_visualize/out/%s_carousel.png", frame_to_use, version_info))
```

#### USGS VisID thumbnail

This static thumbnail is used as the thumbnail and preview image for the animation that is uploaded to Drupal. It should be added as its own media object by the Web Communications team and then can be linked to in the Drupal video submission form.

```r
visid_file <- "6_visualize/in/visid_overlay.png"

# Get viz frame dimensions and then divide by 2 bc we 
# double them in combine_animation_frame
timestep_frame_config <- remake::fetch("timestep_frame_config")
viz_config_dim <- lapply(timestep_frame_config, function(x) x/2) 

# Add cover over logo!
run_magick_cmd(sprintf(
    'convert %s -fill white -draw "rectangle 0,%s %s,%s" %s',
    frame_to_use, 
    timestep_frame_config$height,
    timestep_frame_config$width/6,
    timestep_frame_config$height - timestep_frame_config$height/8,
    "6_visualize/tmp/frame_logo_covered.png"))

# Resize the existing frame to fit the black bottom bar
# without changing aspect ratio
run_magick_cmd(sprintf(
    "convert %s -resize %sx%s %s",
    "6_visualize/tmp/frame_logo_covered.png", 
    viz_config_dim$width - viz_config_dim$width*0.08691406,
    viz_config_dim$height - viz_config_dim$height*0.08691406,
    "6_visualize/tmp/frame_resized.png"))

# Put resized frame into an appropriately sized image but with
#  space at the bottom for the bar
#   1. Create image that is the right size but just blank
run_magick_cmd(sprintf("convert -size %sx%s canvas:white 6_visualize/tmp/drupal_still.png", viz_config_dim$width, viz_config_dim$height))
# Now add the new frame
run_magick_cmd(sprintf(
    "convert -composite -gravity north %s %s %s",
    "6_visualize/tmp/drupal_still.png", 
    "6_visualize/tmp/frame_resized.png", 
    "6_visualize/tmp/frame_resized_ready.png"))

run_magick_cmd(sprintf(
    "convert -composite -gravity southwest %s %s 6_visualize/out/%s_visid_thumbnail.png",
    "6_visualize/tmp/frame_resized_ready.png", 
    visid_file, 
    version_info))
```

#### Square thumbnail

This creates a square thumbnail showing only the map and not the title or datewheel. This might be used by the Web Communications team, but I can't remember if they still use it. We might be able to delete in the future.

```r
thumbnail_dim <- 500

viz_config <- yaml::yaml.load_file("viz_config.yml")
width <- viz_config[["width"]]
height <- viz_config[["height"]]
x_pos <- viz_config[["footnote_cfg"]][["x_pos"]]
y_pos <- viz_config[["footnote_cfg"]][["y_pos"]]

# Crop frame to map only view & resize so that width is 500
run_magick_cmd(sprintf("convert %s -gravity West -chop %sx0 -gravity South -chop 0x%s -resize %sx%s 6_visualize/tmp/drupal_thumbnail_intermediate.png", frame_to_use, width*x_pos*0.80, height*y_pos*2, thumbnail_dim, thumbnail_dim))

# Create a square white image
run_magick_cmd(sprintf("convert -size %sx%s canvas:white 6_visualize/tmp/drupal_thumbnail.png", thumbnail_dim, thumbnail_dim))

# Paste the map centered in the square white image
run_magick_cmd(sprintf("convert -composite -gravity center 6_visualize/tmp/drupal_thumbnail.png 6_visualize/tmp/drupal_thumbnail_intermediate.png 6_visualize/out/%s_square_thumbnail.png", version_info))
```

### Restructure code and build a new Instagram version

Creating an Instagram-optimized version is not as simple as the others because we need the whole video to be square and in a different layout, where the different elements may be bigger or smaller than they appear on the rectangular versions. As such, we actually have to edit some of the `viz_config.yml`, rebuild the video animation, and then run the code snippet to turn the video into a square. So, this should be done after all of your other products are complete AND you really truly have the final approval (the others should be done after approval, but are easy to re-generate should you need to; this one is more complex and so should be done as one of the final steps before publishing).

#### Edit `viz_config.yml`, maybe `callouts_cfg.yml`

To update the `viz_config.yml` so that our title and other info are larger and in appropriate locations for our cut/paste to square later on, comment out everything below the comment `# Comment this out when building the Instagram version` and above `# End of regular version specs`. Then, *uncomment* everything below the comment that says `# End of regular version specs`. Double check that the text under `title_config > subtitle` has the appropriate dates and update if needed. Save the file. 

You may want to increase the text size of callouts as specified in `callouts_cfg.yml`, so that they can easily be read on our square version. Adjusting the size may require additional adjusting of position or layout. By default, all of the callouts had `cex=6`. Anything smaller than 6 should be increased. We have found that a `cex` between 6 and 8 works best for the Instagram version. Save the file following any changes. Note that you may want to retain a copy of your unchanged `callouts_cfg.yml` for the default Twitter version only for use in the future water year version. Name the copy appropriately prior to making any changes related to Instagram.

#### Rebuild the animation

Now that the specifications for frames are updated and ready for the Instagram version, you need to rebuild all of the frames. Use the code below. No need to rename this one from `year_in_review.mp4` to something else since we will process it further in the next step.

```r
sysfonts::font_add_google('Abel','abel')

scipiper::scmake('6_intro_gif_tasks.yml', remake_file = '6_visualize.yml', force = TRUE)
scipiper::scmake('6_visualize/log/6_intro_gif_tasks.ind', remake_file = '6_visualize.yml', force=TRUE)

scipiper::scmake('6_timestep_gif_tasks.yml', remake_file = '6_visualize.yml', force = TRUE)
scipiper::scmake('6_visualize/log/6_timestep_gif_tasks.ind', remake_file = '6_visualize.yml', force=TRUE)

# Note that you may need to delete previous versions of these for them to rebuild if you made changes
scipiper::scmake('6_pause_gif_tasks.yml', remake_file = '6_visualize.yml', force=TRUE)
scipiper::scmake('6_visualize/log/6_pause_gif_tasks.ind', remake_file = '6_visualize.yml', force=TRUE)

scipiper::scmake('6_final_gif_tasks.yml', remake_file = '6_visualize.yml', force = TRUE)
scipiper::scmake('6_visualize/log/6_final_gif_tasks.ind', remake_file = '6_visualize.yml', force=TRUE)

scipiper::scmake('6_visualize/out/year_in_review.mp4', remake_file = '6_visualize.yml', force = TRUE)
```

#### Run code to create the square, Instagram version

Now that all of the frames and the initial video have been updated using our larger text and position adjustments, we are ready to apply the code below and cut/paste/convert the video into the final square, Instagram version. Make sure you set the `version_info` as we did with earlier code to match the appropriate month boundaries and year for which this is being generated.

```r
version_info <- "river_conditions_apr_jun_2022"
```

Now that we have set the version, you can run all the code in the following chunk. In the end, you should see a file called `6_visualize/out/river_conditions_[month start]_[month end]_[year]_insta.mp4`.

```r
video_file <- "6_visualize/out/year_in_review.mp4"
video_title_covered <- "6_visualize/tmp/no_title.mp4"
video_map_only <- "6_visualize/tmp/map_only.mp4"
video_map_square <- "6_visualize/tmp/map_square.mp4"
video_datewheel <- "6_visualize/tmp/datewheel.mp4"
video_legend <- "6_visualize/tmp/legend.mp4"
video_title <- "6_visualize/tmp/title.mp4"
video_footnote <- "6_visualize/tmp/footnote.mp4"
video_logo <- "6_visualize/tmp/logo.mp4"
video_stitched <- "6_visualize/tmp/stitched.mp4"
video_intro <- "6_visualize/tmp/intro.mp4"
video_outro <- "6_visualize/tmp/outro.mp4"
video_stitched_full_length <- "6_visualize/tmp/stitched_full.mp4"
video_insta <- sprintf("6_visualize/out/%s_insta.mp4", version_info)

reg_animation_start <- 4 # seconds into animation that map is first shown
reg_animation_end <- 48 # seconds into animation that map is last shown

insta_dim <- 600 # square shape

viz_config <- yaml::yaml.load_file("viz_config.yml")
width <- viz_config[["width"]]/2
height <- viz_config[["height"]]/2

## Create a video that contains only the datewheel

# Find wheel location
wheel_radius <- viz_config[["datewheel_cfg"]][["wheel_per"]]*width/2
wheel_center_x <- viz_config[["datewheel_cfg"]][["x_pos"]]*width
wheel_center_y <- viz_config[["datewheel_cfg"]][["y_pos"]]*height

# Now crop out just wheel
buffer<-1.05
system(sprintf(
  'ffmpeg -y -i %s -vf "crop=%s:%s:%s:%s" %s', 
  video_file,
  wheel_radius*2*buffer, # diameter of wheel 
  wheel_radius*2*buffer,
  wheel_center_x - wheel_radius*buffer,
  wheel_center_y + wheel_radius*1.65,
  video_datewheel
))

## Create a video that contains only the legend

# Find legend location
legend_guess_width <- 0.10*width #10% width of video
legend_guess_height <- 0.35*height #30% height of video
legend_x <- viz_config[["legend_cfg"]][["x_pos"]]*width
legend_y <- viz_config[["legend_cfg"]][["y_pos"]]*height

# Now crop out just legend and scale to be bigger
system(sprintf(
  'ffmpeg -y -i %s -vf "crop=%s:%s:%s:%s" %s', 
  video_file,
  legend_guess_width,  
  legend_guess_height,
  legend_x - legend_guess_width/1.5,
  height - legend_y*1.02,
  video_legend
))

## Create a video that contains only the title

# Find title location
title_guess_width <- wheel_radius*2*1.46 # diameter of wheel + some
title_guess_height <- 0.17*height #20% height of video
title_x <- viz_config[["title_cfg"]][["x_pos"]]*width
title_y <- viz_config[["title_cfg"]][["y_pos"]]*height

# Now crop out just title
system(sprintf(
  'ffmpeg -y -i %s -vf "crop=%s:%s:%s:%s" %s', # scale=%s:-1
  video_file,
  title_guess_width,  
  title_guess_height,
  0,
  0,
  # width/3, # Scale to fit 1/3 of the final video
  video_title
))


# Create a video that contains only the footnote

# Find logo location
footnote_guess_width <- 0.60*width #10% width of video
footnote_guess_height <- 0.05*height #3% height of video
footnote_x <- viz_config[["footnote_cfg"]][["x_pos"]]*width
footnote_y <- viz_config[["footnote_cfg"]][["y_pos"]]*height

# Now crop out just logo
system(sprintf(
  'ffmpeg -y -i %s -vf "crop=%s:%s:%s:(ih-%s)" %s', # scale=%s:-1
  video_file,
  footnote_guess_width,  
  footnote_guess_height,
  footnote_x,
  footnote_y,
  video_footnote
))

## Crop video to create a map version

# Title bleeds into map a bit, so need to cover title part with drawbox
system(sprintf(
  'ffmpeg -y -i %s -vf "drawbox=x=0:y=0:w=%s:h=%s:t=max:color=white" %s', 
  video_file,
  title_guess_width, 
  title_guess_height,
  video_title_covered
))

# Find edge of map
x_pos <- viz_config[["footnote_cfg"]][["x_pos"]]
map_info_cutoff <- width*x_pos*0.90
map_guess_width <- width*0.992 - map_info_cutoff
map_guess_height <- height - footnote_guess_height

# Now crop to map
system(sprintf(
  'ffmpeg -y -i %s -vf "crop=%s:%s:%s:%s" %s', 
  video_title_covered,
  map_guess_width, 
  map_guess_height,
  map_info_cutoff,
  0,
  video_map_only
))

## Make map video a square with white space on top by
#   increasing height to be the same as width
system(sprintf(
  'ffmpeg -y -i %s -vf "pad=iw:iw:(ow-iw)/2:0:color=white" %s', 
  video_map_only,
  video_map_square
))

# Create a video that contains only the logo

# Find logo location
logo_guess_width <- wheel_radius*2*1.2 # diameter of wheel
logo_guess_height <- 0.10*height #10% height of video
logo_x <- 0
logo_y <- 0

# Now crop out just logo
system(sprintf(
  'ffmpeg -y -i %s -vf "crop=%s:%s:%s:%s" %s', # scale=%s:-1
  video_file,
  logo_guess_width,  
  logo_guess_height,
  0,
  height,
  video_logo
))

center_under_map <- sprintf("%s + (H-%s)/2", map_guess_height, map_guess_height)
center_under_map_with_another <- sprintf("%s + (H-%s)/3", map_guess_height, map_guess_height)

# Overlay these videos on top of existing video
# And cut out intro & outro (reg animation starts at 4 seconds, ends at 45)
system(sprintf(
  'ffmpeg -y -i %s -i %s -i %s -i %s -i %s -i %s -filter_complex "overlay=%s:%s,overlay=%s:%s,overlay=%s:%s,overlay=%s:%s,overlay=%s:%s,scale=%s:-1" -ss 00:00:%s  -t 00:00:%s %s', 
  video_map_square,
  video_datewheel,
  video_legend,
  video_title,
  video_logo,
  video_footnote,
  # Add date wheel
  "(W-(W/3))",# Center in right half
  sprintf("%s - (h/2)", center_under_map), # Center in white space below map
  # Add legend
  "(W/2)-(w/4)", # Center (but ever so slightly to the right since the title is wider than the wheel)
  sprintf("%s - (h/2)", center_under_map), # Center in white space below map
  # Add title
  "(W*0.05)",# Just in from the left
  sprintf("%s - (h/2)", center_under_map_with_another), # Center in white space below map & above logo
  # Add logo
  "(W*0.05)",# Left
  sprintf("%s + (H-%s)*2/3 - (h/2)", map_guess_height, map_guess_height), # Center in white space below map & below title
  # Add footnote
  sprintf("(W/2)-(w/2)", footnote_guess_width), # Center
  sprintf("(H-%s)", footnote_guess_height*1.1), # Just up from bottom
  insta_dim,
  sprintf("%02d", reg_animation_start), # start animation
  sprintf("%02d", reg_animation_end-reg_animation_start), # end animation
  video_stitched
))


# Need intro text centered
# So cutting video and then adding in at the beginning
system(sprintf(
  'ffmpeg -y -i %s -ss 00:00:00 -t 00:00:%s -vf "crop=iw:(ih-%s):0:0,pad=iw:iw:(ow-iw)/2:(oh-ih)/2:color=white,scale=%s:-1" %s', # scale=%s:-1
  video_file,
  sprintf("%02d", reg_animation_start-1),
  logo_guess_height,  
  insta_dim,
  video_intro
))

# Now do the same thing to the outro
system(sprintf(
  'ffmpeg -y -i %s -ss 00:00:%s -vf "crop=iw:(ih-%s):0:0,pad=iw:iw:(ow-iw)/2:(oh-ih)/2:color=white,scale=%s:-1" %s', # scale=%s:-1
  video_file,
  sprintf("%02d", reg_animation_end+1),
  logo_guess_height,  
  insta_dim,
  video_outro
))

# Bring them all together
files_to_cat_fn <- "6_visualize/tmp/videos_to_concat.txt"
writeLines(sprintf("file '%s'", c(basename(video_intro), basename(video_stitched), basename(video_outro))), files_to_cat_fn)

system(sprintf(
  'ffmpeg -y -safe 0 -f concat -i %s -c copy %s',
  files_to_cat_fn,
  video_stitched_full_length
))

# Now edit to be 29 fps as we learned 1/21/2021 - Insta won't let you post too low of an fps
system(sprintf(
  'ffmpeg -y -i %s -r 29 %s',
  video_stitched_full_length,
  video_insta
))

```

## Disclaimer

This software is in the public domain because it contains materials that originally came from the U.S. Geological Survey, an agency of the United States Department of Interior. For more information, see the official USGS copyright policy at [http://www.usgs.gov/visual-id/credit_usgs.html#copyright](http://www.usgs.gov/visual-id/credit_usgs.html#copyright)

This information is preliminary or provisional and is subject to revision. It is being provided to meet the need for timely best science. The information has not received final approval by the U.S. Geological Survey (USGS) and is provided on the condition that neither the USGS nor the U.S. Government shall be held liable for any damages resulting from the authorized or unauthorized use of the information. Although this software program has been used by the USGS, no warranty, expressed or implied, is made by the USGS or the U.S. Government as to the accuracy and functioning of the program and related program material nor shall the fact of distribution constitute any such warranty, and no responsibility is assumed by the USGS in connection therewith.

This software is provided "AS IS."


[
  ![CC0](http://i.creativecommons.org/p/zero/1.0/88x31.png)
](http://creativecommons.org/publicdomain/zero/1.0/)
